{
  "language": "Solidity",
  "sources": {
    "contracts/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/BeTrusty.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport {AggregatorV3Interface} from \"./AggregatorV3Interface.sol\";\nimport \"./Verifier.sol\";\n\ncontract BeTrusty {\n    AggregatorV3Interface internal dataFeed;    \n    Verifier internal verifier;\n    uint256 public immutable PRICE_PROOF_ONCHAIN = 20e18; // equivale a 20\n    address public owner;\n\n    // Mapping para almacenar que la prueba ya ha sido utilizada\n    // Cuando el usuario decide hacer valida su \"reputacion\" on-chain\n    // almacenamos aqui el secret generada en la primera ZKP\n    mapping(uint256 => bool) public s_nullifierHash;\n\n    struct Proof {\n        uint[2] a;\n        uint[2][2] b;\n        uint[2] c;\n    }\n\n    // Scroll Seplia Address\n    // ETH/USD 0x59F1ec1f10bD7eD9B938431086bC1D9e233ECf41\n    // Verificar en : https://docs.chain.link/data-feeds/price-feeds/addresses?network=scroll&page=1\n    constructor() {\n        dataFeed = AggregatorV3Interface(0x59F1ec1f10bD7eD9B938431086bC1D9e233ECf41);\n        verifier = Verifier(0x59F1ec1f10bD7eD9B938431086bC1D9e233ECf41);        \n        owner = msg.sender;\n    }\n\n    // Función para solo validar la prueba\n    function verifyBeTrusty(\n        Proof memory proof,\n        uint[1] memory pubSignals\n    ) external view returns (bool) {\n        return verifier.verifyProof(proof.a, proof.b, proof.c, pubSignals);\n    }\n\n    // Función para solo validar la prueba\n    function isProofNullified(\n        uint[1] memory pubSignals\n    ) external view returns (bool) {\n        return s_nullifierHash[pubSignals[0]];\n    }\n\n    // Función para validar la prueba y registrarla on-chain\n    // Se deben pagar 20 USD = PRICE_PROOF_ONCHAIN\n    function verifyAndRegisterBeTrusty(\n        Proof memory proof,\n        uint[1] memory pubSignals\n    ) external payable {\n        require(!s_nullifierHash[pubSignals[0]], \"Already nullified!\");\n        //uint256 requiredETH = calculateRequiredETH();\n        require(msg.value >= calculateRequiredETH(), \"Insufficient ETH sent\");\n        require(\n            verifier.verifyProof(proof.a, proof.b, proof.c, pubSignals),\n            \"Proof invalid\"\n        );\n        s_nullifierHash[pubSignals[0]] = true;\n    }\n\n    // Función para calcular la cantidad de ETH equivalente a 20 USD\n    // segun el precio de Ethereum\n    function calculateRequiredETH() public view returns (uint256) {\n        int price = getChainlinkDataFeedLatestAnswer();\n        require(price > 0, \"Invalid price\");\n        uint256 adjustedPrice = uint256(price) * 10 ** 10; // Ajustar decimales del precio a 18\n        uint256 amountInETH = (PRICE_PROOF_ONCHAIN * 10 ** 18) / adjustedPrice; // Cantidad en WEI\n        return amountInETH;\n    }\n\n    // Convierte el valor en WEI devuelto en calculateRequiredETH()\n    // a la cantidad en USDT que deberia dar siempre aprox 20 en 8 decimales\n    function weiToUsd(uint256 _wei) public view returns (uint256) {\n        return\n            (_wei * uint256(getChainlinkDataFeedLatestAnswer())) / (10 ** 18); //\n    }\n\n    // Retorna el precio de ETH/USD\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\n        (, int answer, , uint timeStamp, ) = dataFeed.latestRoundData();\n        require(timeStamp > 0, \"Round has not ended\");\n        return answer;\n    }\n\n    function undoNullified(uint[1] memory pubSignals) external onlyOwner {\n        s_nullifierHash[pubSignals[0]] = false;\n    }\n\n    function updateVerifier(address _verifier) external onlyOwner {\n        verifier = Verifier(_verifier);\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        owner = _newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n}\n"
    },
    "contracts/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 14635464255758254817211398285735981911297597250721916823906084297428433707114;\n    uint256 constant alphay  = 18970485537788556498196647811553359426234755644726375731737139019794579656461;\n    uint256 constant betax1  = 795119930684825241196546030715108851083107609653758507626110023475189187899;\n    uint256 constant betax2  = 21690275199638608601423542597390602504500545426915694085156785354284420798672;\n    uint256 constant betay1  = 13380938910047959063498455064426143247871622287049043963149957269801240060041;\n    uint256 constant betay2  = 10187046278853116744101579947947031260591546686036364817829300749226541301671;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 15729344185319547036582641988314043754643123246494318955491596466767925844278;\n    uint256 constant deltax2 = 18555164535758186425640360263102307664102511063667945721630453701773616744379;\n    uint256 constant deltay1 = 15201867047966822647578942254831394592424122227967946152853122148144705504012;\n    uint256 constant deltay2 = 18700338436335940696645664652917879148269922374695212732645389658376631451372;\n\n    \n    uint256 constant IC0x = 15295463304573243721085702254645495999734538064328692042892455736415867566373;\n    uint256 constant IC0y = 15795318249654584947845717970776558935881529716864263338541925446293869612107;\n    \n    uint256 constant IC1x = 18407749578554627223951466227283440548282354009760651462114360387558765746833;\n    uint256 constant IC1y = 14738098379743589895833723065256725253566168616121543037274203477319965061855;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[1] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, r)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}